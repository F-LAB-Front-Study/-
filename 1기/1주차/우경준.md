# 하루 3분 네트워크 교실 - 1장 네트워크 기초 지식

- 컴퓨터 네트워크란?

  컴퓨터와 컴퓨터가 그물망처럼 통신 매체로 연결되어서 데이터를 운반하는 것

- 네트워크가 왜 좋아요?

  리소스를 적절한 곳에서 유용하게 활용하기 위해 복수의 컴퓨터에서 정보를 공유할 수 있는 것이 좋다.

- 컴퓨터끼리는 어떻게 통신하나요?

  각 컴퓨터에는 통신을 위한 “인터페이스”가 존재하고 데이터는 컴퓨터끼리의 약속인 “프로토콜”에 따라 송신 및 수신을 해야한다.

  프로토콜이 없으면 전송한 데이터의 의도대로 수신할 수 없다.

## 연결 방법

- 패킷통신

  보통 인터넷에선 큰 데이터를 “패킷”으로 나누어 보냅니다.

  복수의 컴퓨터가 통신선을 최대한 활용할 수 있기 때문에 채택되었습니다.

  ![회선교환vs패킷교환.png](/public/woo/images/line.png)

  - 회선 교환

  공통으로 사용하는 “회선”을 돌려가면서 각 client끼리 연결한다.

    연결되는 동안 회선이 점유되므로 회선 숫자만큼 동시 연결이 가능하다.

  - 패킷 교환

    패킷 교환기와 교환기 그리고 컴퓨터가 복수로 연결된다.

    각 패킷이 어디로 가야되는지 스스로 들고 있기 때문에, 각 컴퓨터끼리 하나의 회선을 점유할 필요가 없다는 장점이 있다.

## 연결 범위

- **세그먼트란**

  케이블 분배기로 연결되는 범위의 네트워크

  즉, 케이블로 직접적으로 연결된 범위의 네트워크이다.

  - 허브와 멀티 액세스 네트워크

  원래는 회선을 T모양으로 하여 직접 연결해야되지만,

  허브라는 것을 이용해 선을 직접 조절할 필요없이 직접 연결시킬 수 있다.

  하나의 케이블에 여러 컴퓨터가 연결된 것이 “멀티 액세스 네트워크” vs 각 하나씩 연결된 것이 “포인트 투 포인트 연결” 이다.

- LAN

  LAN의 정의에서 헷갈리는 것.

  LAN의 범위는 정해져있는 것이 아니라, 직접 개인적으로 책임을 지고 만드는 개인 네트워크이다.

## 프로토콜

![osi&tcpIp.png](/public/woo/images/osi%26tcpIp.png)

- OSI 참조 모델

  데이터 통신을 위한 프로토콜 모델 = OSI 표준 프로토콜 군을 만들기 위한 설계도

  데이터통신을 단계로 나누어 각 단계의 순서를 명확히하고, 이 모델에 따라 프로토콜을 정의하도록 하기 위한 모델

  **데이터 통신은 여러 프로토콜의 묶음으로 이루어져 있고 순서가 있다. 프로토콜 번들**

  **각 계층마다 각각의 역할과 규칙이 있다.**

  **각 계층의 프로토콜은 서로 간섭하지 않는다. 즉, 독립적이다. 캡슐화**

  **하위계층은 상위계층을 위해서 일하고, 상위계층은 하위계층에 관여하지 않는다.**

  (우편 배달원은 봉투랑 편지지랑 거기에 쓰인 내용을 위해 일한다. 하지만, 우편 배달원이 봉투와 편지지를 뭘로 할지는 관여하지 않는다.)

- PDU: 프로토콜 데이터 유닛

  각 프로토콜 계층을 거치면서 해당 프로토콜에 대한 정보를 헤더나 테일에 붙여준다.

  이것을 프로토콜 데이터 유닛이라고 한다.

- 프로토콜이 정해주는 것

  어떤 헤더를 붙일지 결정하는 것.

  데이터를 주고받는 순서 (3-way handshake)

- TCP/IP

  많은 오해로 이 프로토콜은 OCI랑은 전혀 관련이 없다. 하지만 계층구조를 대응시킬 수 있어서 그렇게 설명해주는 곳이 많다. 사실표준.

  IETF(the Internet Engineering Task Force)라는 단체에서 RFC로 제정된 문서를 통해 Protocol을 만든다.

# 웹 소켓

![websocket.png](/public/woo/images/websocket.png)

브라우저와 서버 사이의 interactive한 통신 세션을 설정할 수 있게 하는 고급 기술입니다.

통신 프로토콜로 ws:// wss://로 표현됩니다.

서버로 메세지를 보내고 서버의 응답을 위해 서버를 폴링하지 않고도 이벤트 중심 응답을 받는 것이 가능합니다.

[웹 소켓 - Web API | MDN](https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API)

## 웹 소켓이 필요한 이유, 기존의 HTTP의 한계를 극복하다.

HTTP 통신은 기본적으로 request, 요청과 reponse 응답의 1대1 관계가 성립하는 엄격한 프로토콜입니다.

client의 요청으로 통신을 연결하고 응답을 기다리고 응답을 받으면 그 연결을 끊어버립니다. 이것을 반복하는 단순 프로토콜이죠.

이는 문서전달을 목적으로 초기 웹이 발전했기 때문에, 이렇게 단순한 통신 프로토콜이 되었습니다.

하지만, 웹이 발전함에 따라, 실시간 통신의 수요도 늘었고, 요청이 없어도 일방적으로 받기만하는 상황이 발생하게 되는 일도 많이 발생하게 되었습니다. 예를 들어 채팅같은 것이 대표적입니다.

채팅은 요청과 응답이 1대1 관계로 성립하지 않습니다.

언제든 서로 자유롭게 텍스트 데이터를 보낼 수 있다는 특징이 있습니다.

## Polling, HTTP로 실시간 통신 비슷하게 구현하다.

웹소켓이 없던 시절 실시간 통신의 요구를 충족하기 위해, HTTP를 응용해 실시간 통신처럼 구현한 방법이 있는데, 이것이 바로 “폴링”입니다.

> 일정 간격을 두고 지속적으로 클라이언트에 요청을 보내는 것을 폴링이라고 합니다.

client는 길게 기다리는 request를 하고 그렇게 통신 연결을 합니다. 서버는 응답이 있거나 시간 초과가 되면 연결이 종료, client는 곧바로 요청을 날려 다시 길게 기다리는 연결을 합니다.

client의 요청이 없이도 server에서 일방적으로 데이터가 날아온 것과 같은 효과이니 실시간 통신처럼 보일 수 있습니다.

이렇게 실시간 통신을 흉내낼 수 있습니다.

Socket.io는 내부적으로 websocket을 지원하지 않는 client 환경에서 polling을 통해 실시간 통신을 이어나갑니다.

폴링의 종류에는 “long polling’, “polling”이 있습니다.

![http polling.jpeg](/public/woo/images/http%20polling.jpeg)

![long polling.jpeg](/public/woo/images/long%20polling.jpeg)

[What is HTTP Long Polling ?](https://www.educative.io/answers/what-is-http-long-polling)

[HTTP Polling and Long Polling](https://medium.com/cache-me-out/http-polling-and-long-polling-bd3f662a14f)

## 웹소켓의 탄생

폴링의 단점은 HTTP 그 자체에 있습니다. 매번 요청을 보내고 보낸 요청의 header를 파싱해서 분석하고 응답을 다시 만들고 그것의 헤더를 다시 파싱해서 분석하는 것을 반복해야 했죠.

이것을 해결하기 위해 HTML5부터 웹소켓이 등장했습니다.

웹소켓은 얇은 tarnsposrt layer이며 TCP/IP 스택위에 세워집니다.

웹소켓은 양방향 통신을 지원하며, 한번의 연결로 클라이언트와 서버 모두 자유롭게 데이터를 보낼 수 있습니다.

### 장점

- long polling에서 존재하던 latency 문제를 해결할 수 있습니다.
- 완전한 실시간 비동기 통신으로 자료들을 완전히 자유롭게 주고받을 수 있습니다.
- 보통 XMLHttpRequest를 사용하지 않기 때문에, header를 보내지 않아도 되고, 따라서 data payload의 크기도 줄일 수 있습니다.
- websocket은 firewall을 넘을 수 있기 때문에, firewall 재설정 등의 번거로운 작업이 필요없습니다.

### 단점

- HTTP처럼 끊어지면 자동으로 재 연결을 시도하는 기능은 없습니다. 이것이 웹소켓 관련 수많은 라이브러리 들이 존재하는 이유입니다.
- 2011년 이전 websocket을 지원하지 않는 브라우저에서는 사용할 수 없습니다.

[WebSockets vs Long Polling | Ably Blog: Data in Motion](https://ably.com/blog/websockets-vs-long-polling)
